{"version":3,"sources":["../../../../paket-files/Ionide/ionide-vscode-helpers/Helpers.fs"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAKO;AAAA;AAAE,CAAF;;AAQA;AAbP,mCA0BQ;AAAA,2BACI;AAAA,iBAAe;AAAA;AAA+B,aAA9C,EAA0D;AAAA;AAAqB,aAA/E;AAAgF,SADpF;AACqF,KA3B7F;;AAAA,6BAiCQ;AAAA;AAGC,KApCT;;AAAA,+BA0CQ;AAAA;AAGC,KA7CT;;AAAA,kCAmDQ;AAAA;AAGC,KAtDT;;AAAA,mCA4DQ;AAAA;AAGC,KA/DT;;AAAA,+BAqEQ;AAAA;AAA2B,KArEnC;;AAAA,mCA2EQ;AAAA;AAAyB,KA3EjC;;AAAA,yCAkFQ;AAAA,uBAC2D;AAAA;AAAA;AAAc,SADzE;AAGC,KArFT;;AAAA,mCA4FQ;AAAA,wBAAmE;AAAA;AAAoB;AAAa,SAApG;AAAsG,KA5F9G;;AA8FS,mDA9FT;AAAA;AAAA,KA8FS;;AAjFF;;AAAA;AAbP,CAaO;;;;AAwFA;AArGP,qCAsGkB,6BAtGlB;AAqGO;AArGP,CAqGO;;AAQA;AA7GP,iDAiHY;AAAM;;AAAN;AAAG,KAjHf;;AA6GO;AA7GP,CA6GO;;AAWA;AAxHP,iCA+HmB;AAAA;AAA8B,KA/HjD;;AAAA,mCAgIsD;AAAA,iBAAlC,4BAAkC;AAAG,KAhIzD;;AAAA,mCAmIQ;AAAA;AAAA;AACI,KApIZ;;AAAA,uCAuIQ;AAAA;AAAA;AACI,KAxIZ;;AAAA,iDA2IQ;AAAA;AAAA;AACI,KA5IZ;;AAAA,qCA+IQ;AAAA;AAAA;AACI,KAhJZ;;AAAA,iCAmJY;AAEG,8BADA,UAAH,QAA2B,cACxB;AAEH;AAAA;AAAA;;AAGJ,YAAG,iBAAY,eAAf,EAEI;AAAA;AAA4C,SAFhD,MAIQ;AAA6C,kCAAhC;AAAA,iFAAgB;AAAA;AAAA,kBAAhB;AAAA,cAAgC;AACjD;AADQ;AAXJ,KAnJhB;;AAAA,iEAoKW;AAAA,uBAAkB;AAAA,aAAiB;AAAA;AAAoB,aAArC;AAAqC,SAAvD,EADA,SAAkB;AAAA,aAAiB;AAAA;AAAoB,aAArC;AAAqC,SAAvD,EADH,8BACG,CACA;AAAwD,KApKnE;;AAAA,+BAuKY;AACA;AAAA;AAAA;AAGJ,2BACI;AAAA,gBAAG,OAAH,EACI;AAAA,mCAAmB,oBAAnB,WACQ;AAAA;AAAA;AAAA;AACJ;AADO,yBAAH;AAAA;AAAA,iBADR;AAE2C,aAH/C,MAKI;AAAA,mCAAmB,qCAAnB,WACQ;AAAA;AAAA;AAAA;AACJ;AADO,yBAAH;AAAA;AAAA,iBADR;AAE0C;AAAU,SAR5D;AAJW,KAvKnB;;AAwHO;AAxHP,CAwHO;;AAiEA;AAII;AAAA;AAAI,KAAJ;;AAIF;AAjMT;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiMS;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AARF;;AAgBE;AAzMT;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyMS;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAhBF;;AA4BE;AArNT;AAAA;;AAAA;AAAA;AAAA;;AAqNS;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AA5BF;;AAzLP,iDA2NQ;AAAA,YACQ;AAAO;AACH;;AAGR;AAAA;AAAA;AAAA;AAAA;AAJQ,SADZ;AAAA;AAAA;AAOU,KAlOlB;;AAyLO;AAzLP,CAyLO","file":"Helpers.js","sourceRoot":"/Users/fb/Dropbox/kata/vscode/vscode-sendto-terminal/release","sourcesContent":["namespace Ionide.VSCode.Helpers\n\nopen System\nopen Fable.Core\n\nmodule JS =\n\n    [<Emit(\"($0 != undefined)\")>]\n    let isDefined (o: obj) : bool = failwith \"never\"\n\n//---------------------------------------------------\n//PromisesExt (by Dave)\n//---------------------------------------------------\nmodule Promise =\n    open System\n    open Fable.Core\n    open Fable.Import\n    open Fable.Import.JS\n    \n    /// <summary>\n    /// Creates new promise. \n    /// Constuctor function \"body\" is called with two arguments: \n    /// \"resolve\" - moves promise to fulfilled state, using provided argument as result\n    /// \"reject\" - moves promise to rejected state\n    /// </summary>\n    let create (body: ('T->unit) -> (obj->unit) -> unit) =\n        Promise.Create(fun (resolverFunc : Func<U2<_, _>, _>) (rejectorFunc : Func<_,_>) ->\n            body (fun v -> resolverFunc.Invoke(U2.Case1 v)) (fun e -> rejectorFunc.Invoke e)) \n\n    /// <summary>\n    /// Standard map implementation.\n    /// </summary>\n    let map (a : 'T -> 'R) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(   \n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> a,\n            unbox<Func<obj,unit>> None\n        )\n\n    /// <summary>\n    /// Standard bind implementation.\n    /// </summary>\n    let bind (a : 'T -> Promise<'R>) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(   \n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> a,\n            unbox<Func<obj,unit>> None\n        )\n\n    /// <summary>\n    /// Bind for rejected promise.\n    /// </summary>\n    let catch (a : obj -> Promise<'R>) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(   \n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> None,\n            unbox<Func<obj,U2<'R, PromiseLike<'R>>>> a\n        )\n\n    /// <summary>\n    /// Combination of bind and catch methods. If promise in fulfilled state - a is bound, if in rejected state - then b.\n    /// </summary>\n    let either (a : 'T -> Promise<'R>) (b: obj -> Promise<'R>) (pr : Promise<'T>) : Promise<'R> =\n        pr.``then``(\n            unbox<Func<'T, U2<'R, PromiseLike<'R>>>> a,\n            unbox<Func<obj,U2<'R, PromiseLike<'R>>>> b\n        )\n\n    /// <summary>\n    /// Creates promise (in pending state) from the supplied value.\n    /// </summary>\n    let lift<'T> (a : 'T) : Promise<'T> =\n        Promise.resolve(U2.Case1 a)\n\n    /// <summary>\n    /// Creates promise (in rejected state) with supplied reason.\n    /// </summary>\n    let reject<'T> reason : Promise<'T> =\n        Promise.reject<'T> reason\n\n    /// <summary>\n    /// Allows handing promise which is in fulfilled state. \n    /// Can be used for side-effects. \n    /// </summary>\n    let onSuccess (a : 'T -> unit) (pr : Promise<'T>) : Promise<'T> =\n        pr.``then``(   \n            unbox<Func<'T, U2<'T, PromiseLike<'T>>>> (fun value -> a value; value),\n            unbox<Func<obj,unit>> None\n        )\n\n    /// <summary>\n    /// Allows handing promise which is in rejected state. Propagates rejected promise, to allow chaining.\n    /// Can be used for side-effects. \n    /// </summary>\n    let onFail (a : obj -> unit) (pr : Promise<'T>) : Promise<'T> =\n        pr.catch (unbox<Func<obj, U2<'T, PromiseLike<'T>>>> (fun reason -> a reason |> ignore; reject reason))\n\n    type PromiseBuilder() =\n        member inline x.Bind(m,f) = bind f m\n        member inline x.Return(a) = lift a\n        member inline x.ReturnFrom(a) = a\n        member inline x.Zero() = Fable.Import.JS.Promise.resolve()\n\n[<AutoOpen>]\nmodule PromiseBuilderImp =\n    let promise = Promise.PromiseBuilder()\n\n\n\n//---------------------------------------------------\n//VS Code Helpers\n//---------------------------------------------------\nmodule VSCode =\n    open Fable.Import.vscode\n\n    let getPluginPath pluginName =\n        let ext = extensions.getExtension pluginName\n        ext.extensionPath\n\n\n//---------------------------------------------------\n//Process Helpers\n//---------------------------------------------------\nmodule Process =\n    open Fable.Import.JS\n    open Fable.Import.Node\n    open Fable.Import.vscode\n    open Fable.Core.JsInterop\n\n\n    let isWin () = ``process``.platform = \"win32\"\n    let isMono () = ``process``.platform = \"win32\" |> not\n\n    let onExit (f : obj -> _) (proc : child_process_types.ChildProcess) =\n        proc.on(\"exit\", f |> unbox) |> ignore\n        proc\n\n    let onOutput (f : obj -> _) (proc : child_process_types.ChildProcess) =\n        proc.stdout?on $ (\"data\", f |> unbox) |> ignore\n        proc\n\n    let onErrorOutput (f : obj -> _) (proc : child_process_types.ChildProcess) =\n        proc.stderr?on $ (\"data\", f |> unbox) |> ignore\n        proc\n\n    let onError (f: obj -> _) (proc : child_process_types.ChildProcess) =\n        proc?on $ (\"error\", f |> unbox) |> ignore\n        proc\n\n    let spawn location linuxCmd (cmd : string) =\n        let cmd' =\n            if cmd = \"\" then [||] else cmd.Split(' ')\n            |> ResizeArray\n        let options =\n            createObj [\n                \"cwd\" ==> workspace.rootPath\n            ]\n        if isWin () || linuxCmd = \"\" then\n\n            child_process.spawn(location, cmd', options)\n        else\n            let prms = seq { yield location; yield! cmd'} |> ResizeArray\n            child_process.spawn(linuxCmd, prms, options)\n\n    let spawnWithNotification location linuxCmd (cmd : string) (outputChannel : OutputChannel) =\n        spawn location linuxCmd cmd\n        |> onOutput(fun e -> e.ToString () |> outputChannel.append)\n        |> onError (fun e -> e.ToString () |> outputChannel.append)\n\n    let exec location linuxCmd cmd : Promise<Error * Buffer *Buffer> =\n        let options =\n            createObj [\n                \"cwd\" ==> workspace.rootPath\n            ]\n        Promise.Create<Error * Buffer *Buffer>(fun (resolve : Func<U2<Error * Buffer *Buffer,PromiseLike<Error * Buffer *Buffer>>,_>) (error : Func<obj,_>) ->\n            if isWin () then\n                child_process.exec(location + \" \" + cmd, options, (fun (e : Error) (i : Buffer) (o : Buffer) ->\n                    let arg = e,i,o\n                    resolve.Invoke(arg |> unbox)) |> unbox) |> ignore\n            else\n                child_process.exec(linuxCmd + \" \" + location + \" \" + cmd, options, (fun (e : Error) (i : Buffer) (o : Buffer) ->\n                    let arg = e,i,o\n                    resolve.Invoke(arg |> unbox))|> unbox) |> ignore)\n\n\n//---------------------------------------------------\n//Settings Helpers\n//---------------------------------------------------\nmodule Settings =\n    open Fable.Import.vscode\n    open Fable.Import.Node\n\n    module Toml =\n        [<Emit(\"toml.parse($0)\")>]\n        let parse (str : string) : 'a = failwith \"JS\"\n\n    type FakeSettings = {\n        linuxPrefix : string\n        command : string\n        build : string\n        parameters : string []\n        test : string\n    }\n\n    type WebPreviewSettings = {\n        linuxPrefix : string\n        command : string\n        host : string\n        port : int\n        script : string\n        build : string\n        startString : string\n        parameters : string []\n        startingPage : string\n    }\n\n    type Settings = {\n        Fake : FakeSettings\n        WebPreview : WebPreviewSettings\n    }\n\n    let loadOrDefault<'a> (map : Settings -> 'a)  (def :'a) =\n        try\n            let path = workspace.rootPath + \"/.ionide\"\n            let t = fs.readFileSync(path).toString ()\n                    |> Toml.parse\n                    |> map\n            if JS.isDefined t then t else def\n        with\n        | _ -> def\n"]}